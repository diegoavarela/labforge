import type { PluginState, Skill, Agent, Command, Hook, MCP } from "@/types";

export interface PluginFile {
  path: string;
  content: string;
}

function toSlug(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");
}

function generatePluginJson(state: PluginState): PluginFile {
  const data = {
    name: state.pluginName || "my-plugin",
    version: state.version || "0.1.0",
    description: `Claude Code plugin: ${state.pluginName}`,
    components: {
      skills: state.skills.map((s) => s.name),
      agents: state.agents.map((a) => a.name),
      commands: state.commands.map((c) => c.name),
      hooks: state.hooks.map((h) => h.name),
      mcps: state.mcps.map((m) => m.name),
    },
  };
  return { path: "plugin.json", content: JSON.stringify(data, null, 2) };
}

function generateSkillFiles(skill: Skill): PluginFile[] {
  const slug = toSlug(skill.name);
  const frontmatterLines = [
    "---",
    `name: ${skill.name}`,
    `description: ${skill.description}`,
  ];
  if (skill.source === "registry" && skill.sourceUrl?.startsWith("library:")) {
    frontmatterLines.push(`imported_from: ${skill.sourceUrl.replace("library:", "")}`);
  }
  frontmatterLines.push("---");
  const frontmatter = frontmatterLines.join("\n");

  const files: PluginFile[] = [
    {
      path: `skills/${slug}/SKILL.md`,
      content: `${frontmatter}\n\n${skill.content}`,
    },
  ];

  for (const file of skill.files) {
    files.push({
      path: `skills/${slug}/${file.path}`,
      content: file.content,
    });
  }

  return files;
}

function generateAgentFile(agent: Agent, state: PluginState): PluginFile {
  const slug = toSlug(agent.name);
  const skillNames = state.skills
    .filter((s) => agent.skillIds.includes(s.id))
    .map((s) => s.name);
  const mcpNames = state.mcps
    .filter((m) => agent.mcpIds.includes(m.id))
    .map((m) => m.name);

  const frontmatter = [
    "---",
    `name: ${agent.name}`,
    `description: ${agent.description}`,
    `model: ${agent.model}`,
    `context: ${agent.context}`,
    `allowedTools:`,
    ...agent.allowedTools.map((t) => `  - ${t}`),
    `mcps:`,
    ...mcpNames.map((m) => `  - ${m}`),
    `skills:`,
    ...skillNames.map((s) => `  - ${s}`),
    "---",
  ].join("\n");

  return {
    path: `agents/${slug}.md`,
    content: `${frontmatter}\n\n${agent.instructions}`,
  };
}

function generateCommandFile(command: Command): PluginFile {
  const slug = toSlug(command.name);
  const frontmatter = [
    "---",
    `name: ${command.name}`,
    `description: ${command.description}`,
    "---",
  ].join("\n");

  const nodesYaml = command.nodes
    .map((n) => {
      const lines = [
        `  - id: ${n.id}`,
        `    type: ${n.type}`,
        `    position: { x: ${n.position.x}, y: ${n.position.y} }`,
        `    data: ${JSON.stringify(n.data)}`,
      ];
      return lines.join("\n");
    })
    .join("\n");

  const edgesYaml = command.edges
    .map((e) => {
      const lines = [`  - id: ${e.id}`, `    source: ${e.source}`, `    target: ${e.target}`];
      if (e.sourceHandle) lines.push(`    sourceHandle: ${e.sourceHandle}`);
      if (e.label) lines.push(`    label: ${e.label}`);
      return lines.join("\n");
    })
    .join("\n");

  const body = [`nodes:`, nodesYaml, `edges:`, edgesYaml].join("\n");

  return {
    path: `commands/${slug}.md`,
    content: `${frontmatter}\n\n${body}`,
  };
}

function generateHookFile(hook: Hook): PluginFile {
  const slug = toSlug(hook.name);
  const data = {
    event: hook.event,
    matcher: hook.matcher,
    action: hook.action,
  };
  return {
    path: `hooks/${slug}.json`,
    content: JSON.stringify(data, null, 2),
  };
}

function generateClaudeSettings(mcps: MCP[]): PluginFile | null {
  if (mcps.length === 0) return null;

  const mcpServers: Record<string, { command: string; env?: Record<string, string> }> = {};
  for (const mcp of mcps) {
    const entry: { command: string; env?: Record<string, string> } = {
      command: mcp.installCommand,
    };
    if (Object.keys(mcp.configuredEnvVars).length > 0) {
      entry.env = mcp.configuredEnvVars;
    }
    mcpServers[toSlug(mcp.name)] = entry;
  }

  return {
    path: ".claude/settings.json",
    content: JSON.stringify({ mcpServers }, null, 2),
  };
}

function generateReadme(state: PluginState): PluginFile {
  const lines: string[] = [
    `# ${state.pluginName || "My Plugin"}`,
    "",
    `Claude Code plugin generated by LabForge.`,
    "",
  ];

  if (state.skills.length > 0) {
    lines.push("## Skills", "");
    for (const s of state.skills) {
      lines.push(`- **${s.name}**: ${s.description}`);
    }
    lines.push("");
  }

  if (state.agents.length > 0) {
    lines.push("## Agents", "");
    for (const a of state.agents) {
      lines.push(`- **${a.name}**: ${a.description}`);
    }
    lines.push("");
  }

  if (state.commands.length > 0) {
    lines.push("## Commands", "");
    for (const c of state.commands) {
      lines.push(`- **${c.name}**: ${c.description}`);
    }
    lines.push("");
  }

  if (state.hooks.length > 0) {
    lines.push("## Hooks", "");
    for (const h of state.hooks) {
      lines.push(`- **${h.name}**: ${h.event} -> ${h.action.type}`);
    }
    lines.push("");
  }

  // Collect required env vars
  const envVars: string[] = [];
  for (const mcp of state.mcps) {
    for (const [key, val] of Object.entries(mcp.configuredEnvVars)) {
      if (val.startsWith("${") || val === "") {
        envVars.push(key);
      }
    }
  }

  if (envVars.length > 0) {
    lines.push("## Required Environment Variables", "");
    for (const v of envVars) {
      lines.push(`- \`${v}\``);
    }
    lines.push("");
  }

  lines.push(
    "## Installation",
    "",
    "```bash",
    `claude plugin add github:user/${toSlug(state.pluginName || "my-plugin")}`,
    "```",
    ""
  );

  return { path: "README.md", content: lines.join("\n") };
}

function generateChangelog(state: PluginState): PluginFile | null {
  if (!state.changelog || state.changelog.length === 0) return null;

  const lines: string[] = ["# Changelog", ""];
  for (const entry of state.changelog) {
    const date = new Date(entry.timestamp).toISOString().split("T")[0];
    lines.push(`## ${entry.version} - ${date}`, "");
    for (const change of entry.changes) {
      lines.push(`- ${change}`);
    }
    lines.push("");
  }

  return { path: "CHANGELOG.md", content: lines.join("\n") };
}

function generatePackageJson(state: PluginState): PluginFile | null {
  if (state.mcps.length === 0) return null;

  const data = {
    name: toSlug(state.pluginName || "my-plugin"),
    version: state.version || "0.1.0",
    description: `Claude Code plugin: ${state.pluginName}`,
    keywords: ["claude-code", "plugin"],
    "claude-plugin": true,
  };
  return { path: "package.json", content: JSON.stringify(data, null, 2) };
}

export function generatePluginStructure(state: PluginState): PluginFile[] {
  const files: PluginFile[] = [];

  files.push(generatePluginJson(state));

  for (const skill of state.skills) {
    files.push(...generateSkillFiles(skill));
  }

  for (const agent of state.agents) {
    files.push(generateAgentFile(agent, state));
  }

  for (const command of state.commands) {
    files.push(generateCommandFile(command));
  }

  for (const hook of state.hooks) {
    files.push(generateHookFile(hook));
  }

  const settings = generateClaudeSettings(state.mcps);
  if (settings) files.push(settings);

  files.push(generateReadme(state));

  const changelog = generateChangelog(state);
  if (changelog) files.push(changelog);

  const pkg = generatePackageJson(state);
  if (pkg) files.push(pkg);

  return files;
}
